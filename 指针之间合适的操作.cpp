#include <iostream>
using namespace std;

/*
测试来源：
	某面试书上说明，指针在C++中经常当做整型进行处理，但是并不能进行所有的整型常用的运算。例如两个指针之间不能相乘不能相除不能相加，这些都是没有意义的，是编译器不能接受的。
	其次，指针主要的操作是与整型相加相减（包括自增自减），两个指针相减（但是这两个指针要指向同一个数组中的元素，否则这个运算是结果是未定义的）。除此之外，指针还可以进行 < > <= >= 之类的用于判断在同一个数组中相对的位置。
*/

int main(){
	int * p1, *p2;
	//p1 * p2; //提示二元运算符 * 不接受int*类型的参数，编译不通过
	//p1 / p2;  //结果同 *
	//p1 + p2;  //结果同 *  不能进行两个指针的相加

	//一个指针加上某一个整型值，得到的地址取决于这个指针的类型，如果是char那么向下移动1  如果是int向下移动4 如果是double向下移动8

	//两个指针指向的元素在同一个数组中，那么可进行相减的操作，指针相减操作的结果是两个元素在数组中的相对位置（所以如果是两个不同的类型，是没有意义的）
	int arr[5] = {0};
	p1 = &arr[0];
	p2 = &arr[3];
	cout << p1 - p2 << endl;   //结果-3 获取到的是两个元素的相对位置  与具体的元素的类型无关
	
	//不同类型指针相减  当然由于C++是强类型语言  这里的测试一定程度上有点多余
	//char * p3 = 1000;
	//p3 - p1;  //类型不匹配  不合法

	p1 = (int*)100; p2 = (int*)102; //整型到指针  需要强制转换
	cout << p2 - p1 << endl;  //结果是0 内部的计算应该是将两个整型相减  然后模上 sizeof(int)  这种操作结果按照说明是未定义的，现实中也不具有实际意义。
	return 0;
}